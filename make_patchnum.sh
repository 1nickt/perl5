#!/bin/sh

# this script is used to regenerate a number of special build files
# based on either information contained in a file called .patch or
# directly from git.
# The files involved are:
#   .patchnum         # information about the current checkout
#   lib/Config_git.pl # holds some special configure settings related to git
#   unpushed.h        # header file used by patchlevel.h to store unpushed commits

config_file="lib/Config_git.pl"
header_file="git_version.h"
patch_file=".patch"

git_dir=`git rev-parse --git-dir 2>/dev/null`
existing_config=`cat $config_file 2>/dev/null`
existing_header=`cat $header_file 2>/dev/null`

unpushed_commits='/*no-op*/'
if [ -s $patch_file ] ; then
	# this is the minimal expectation for the 
	read branch snapshot_created commit_id describe < .patch
	changed=""
	extra_info="git_snapshot_date='$snapshot_created'"
	commit_title='Snapshot of:'
elif [ -n "$git_dir" ]; then
	branch=`git branch | awk 'BEGIN{ORS=""} /^\* [^(]/ { print $2 }'`
	test -n "$branch" && remote=`git config branch.$branch.remote`
	test -n "$branch" && merge=`git config branch.$branch.merge | sed s,refs/heads/,,`
	commit_id=`git rev-parse HEAD`
	changed=`git diff-index --name-only HEAD`
	describe=`git describe --tags`
	commit_created=`git log -1 --pretty='format:%ci'`
	extra_info="git_commit_date='$commit_created'"
	if [ -n "$merge" ] && [ -n "$remote" ]; then
		unpushed_commit_list=`git cherry $remote/$merge | awk 'BEGIN{ORS=","} /\+/ {print $2}' | sed -e 's/,$//'`
		unpushed_commits=`git cherry $remote/$merge | awk 'BEGIN{ORS="\t\\\\\n"} /\+/ {print ",\"" $2 "\""}'`

		if [ -n "$unpushed_commits" ]; then
			commit_title="Local Commit:"
			ancestor=`git rev-parse $remote/$merge`
			extra_info="$extra_info
git_ancestor='$ancestor'
git_remote_branch='$remote/$merge'
git_unpushed='$unpushed_commit_list'"
		fi
			
	fi
else
	cat <<SNDOGS
Something is wrong with your source tree. You should 
either have a .git directory and a functional git toolset
OR should have a .patch file in the source tree. Please
report the particulars of this situation to 
perl5-porters@perl.org.
SNDOGS
	exit 2
fi

# Set up defaults for various values
if [ -n "$changed" ]; then
	changed="true"
	commit_title="Derived from:"
	status="#define PERL_GIT_UNCOMMITTED_CHANGES uncommitted-changes"
else
	status="/* clean working directory */"
fi
test -z "$commit_title" && commit_title='Commit id:'

new_header=`cat <<EOFTEXT
/***************************************************************************
* WARNING: $header_file is automatically generated by make_patchnum.sh 
*          DO NOT EDIT DIRECTLY - edit make_patchnum.sh instead      
****************************************************************************/
#define PERL_PATCHNUM $describe
$status
#define PERL_GIT_UNPUSHED_COMMITS $unpushed_commits 
/*leave-this-comment*/
EOFTEXT
`
new_config=`cat <<EOFDATA
#######################################################################
# WARNING: $config_file is generated by make_patchnum.sh   
#          DO NOT EDIT DIRECTLY - edit make_patchnum.sh instead 
#######################################################################
\\$Config::Git_Data=<<'ENDOFGIT';
git_commit_id='$commit_id'
git_describe='$describe'
git_branch='$branch'
git_uncommitted_changes='$changed'
git_commit_id_title='$commit_title'
$extra_info
ENDOFGIT
EOFDATA
`
# only update the files if necessary, other build product depends on these files
if [ "$new_config" != "$existing_config" ] || [ "$existing_header" != "$new_header" ]; then
	echo "Updating $header_file and $config_file"
	echo "$new_config" > $config_file
	echo "$new_header" > $header_file
else
	echo "Reusing $header_file and $config_file"
fi

