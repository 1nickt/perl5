#!perl

# This file specifies an array-of-hashes that define snippets of code that
# can be run by various measurement and profiling tools.
#
# The basic idea is that any time you add an optimisation that is intended
# to make a particular construct faster, then you should add that construct
# to this file.
#
# Under the normal test suite, the test file benchmarks.t does a basic
# compile and run of each of these snippets; not to test performance,
# but just to ensure that the code doesn't have errors.
#
# Over time, it is intended that various measurement and profiling tools
# will be written that can run selected (or all) snippets in various
# environments. These will not be run as part of a normal test suite run.
#
# It is intended that the tests in this file will be lightweight; e.g.
# a hash access, an empty function call, or a single regex match etc.
#
# This file is designed to be read in by 'do' (and in such a way that
# multiple versions of this file from different releases can be read in
# by a single process).
#
# The top-level array has name/hash pairs (we use an array rather than a
# hash so that duplicate keys can be spotted) Each name is a token that
# describes a particular test. Code will be compiled in the package named
# after the token, so it should match /^(\w|::)+$/a. It is intended that
# this can be used on the command line of tools to select particular
# tests.
# In addition, the package names are arranged into an informal hierarchy
# whose top members are (this is subject to change):
#
#     call::     subroutine and method handling
#     expr::     expressions: e.g. $x=1, $foo{bar}[0]
#     loop::     structural code like for, while(), etc
#     regex::    regular expressions
#     string::   string handling
#     hash::     hashes
#     array::    arrays
#
#
# Each hash has three fields:
#
#   desc is a description of the test
#   setup is a string containing setup code
#   code  is a string containing the code to run in a loop
#
# So typically a benchmark tool might do something like
#
#   eval "package $token; $setup; for (1..1000000) { $code }"
#
# Currently the only tool that uses this file is Porting/bench.pl;
# try C<perl Porting/bench.pl --help> for more info


[
    'call::sub::3_args' => {
        desc    => 'function call with 3 local lexical vars',
        setup   => 'sub f { my ($a, $b, $c) = @_ }',
        code    => 'f(1,2,3)',
    },

    'expr::assign::scalar_lex' => {
        desc    => 'lexical $x = 1',
        setup   => 'my $x',
        code    => '$x = 1',
    },
    'expr::assign::2list_lex' => {
        desc    => 'lexical ($x, $y) = (1, 2)',
        setup   => 'my ($x, $y)',
        code    => '($x, $y) = (1, 2)',
    },
    'expr::loop::foreach_intrange' => {
        desc    => 'lexical: ++$x foreach 1..100',
        setup   => 'my $x = 0;',
        code    => '++$x foreach 1..100;',
    },
    'expr::loop::foreach_array' => {
        desc    => 'lexicals: $x += $_ foreach @a (100 elem)',
        setup   => 'my $x = 0; my @a = ((1) x 100)',
        code    => '$x += $_ foreach @a;',
    },
    'expr::loop::cstyle_for' => {
        desc    => 'lexicals: C style for loop and additions',
        setup   => 'my $y = 0;',
        code    => 'for (my $x = 0; $x < 100; ++$x) {$y+=$x;}',
    },

    'hash::create::empty' => {
        desc    => 'creating empty hash refs',
        setup   => '',
        code    => '+{}',
    },
    'hash::create::five_keys' => {
        desc    => 'creating hash ref initialized with five short keys',
        setup   => '',
        code    => '+{a => undef, b => undef, c => undef, d => undef, e => undef}',
    },
    'hash::read::short_key' => {
        desc    => 'read-accessing short key in small hash',
        setup   => 'my %x = (map {$_ => undef} "a".."z");',
        code    => '$x->{g}',
    },
    'hash::write::short_key' => {
        desc    => 'write-accessing short key in small hash',
        setup   => 'my %x = (map {$_ => undef} "a".."z");',
        code    => '$x->{g} = undef',
    },

    'array::create::empty' => {
        desc    => 'creating empty array refs',
        setup   => '',
        code    => '[]',
    },
    'array::create::hundred_ints' => {
        desc    => 'creating array ref with 100 ints',
        setup   => '',
        code    => '[1..100]',
    },
    'array::modify::push_pop' => {
        desc    => 'array: one push, one pop',
        setup   => 'my @x = (1..10);',
        code    => 'push @x, 1; pop @x;',
    },
    'array::modify::push_shift' => {
        desc    => 'array: one push, one shift',
        setup   => 'my @x = (1..10);',
        code    => 'push @x, 1; shift @x;',
    },
    'array::modify::unshift_pop' => {
        desc    => 'array: one unshift, one pop',
        setup   => 'my @x = (1..10);',
        code    => 'unshift @x, 1; pop @x;',
    },
    'array::modify::unshift_shift' => {
        desc    => 'array: one unshift, one shift',
        setup   => 'my @x = (1..10);',
        code    => 'unshift @x, 1; shift @x;',
    },
];

